С созданием объектов стало понятнее. И теперь самое время посмотреть на структурные паттерны. Их цель — построение удобных в поддержке иерархий классов и их взаимосвязей. Одним из первых и всем известных паттернов :
#### "**Заместитель**" (Proxy).

Заместитель имеет тот же интерфейс, что и реальный объект, поэтому для клиента нет разницы — работать через заместителя или напрямую. Самым простым примером является [java.lang.reflect.Proxy](https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html):

```java
import java.util.*;
import java.lang.reflect.*;
class Main {
  public static void main(String[] arguments) {
    final Map<String, String> original = new HashMap<>();
    InvocationHandler proxy = (obj, method, args) -> {
      System.out.println("Invoked: " + method.getName());
      return method.invoke(original, args);
    };
    Map<String, String> proxyInstance = (Map) Proxy.newProxyInstance(
        original.getClass().getClassLoader(),
        original.getClass().getInterfaces(),
        proxy);
    proxyInstance.put("key", "value");
    System.out.println(proxyInstance.get("key"));
  }
}
```

Как видно, в примере у нас есть original — это `HashMap`, который реализует интерфейс `Map`. Мы далее создаём прокси, который замещает оригинальную `HashMap` для клиентской части, которая вызывает методы `put` и `get`, добавляя во время вызова свою логику. Как мы видим, взаимодействие в паттерне идёт через интерфейсы. Но иногда заместителя недостаточно.
И тогда может быть использован паттерн :
#### "**Декоратор**" (Decorator).

Декоратор ещё называют обёрткой или враппером (`Wrapper`). Прокси и декоратор очень похожи, но если посмотреть на пример — будет видна разница:

```java
import java.util.*;
class Main {
  public static void main(String[] arguments) {
    List<String> list = new ArrayList<>();
    List<String> decorated = Collections.checkedList(list, String.class);
    decorated.add("2");
    list.add("3");
    System.out.println(decorated);
  }
}
```

В отличии от прокси, декоратор оборачивается вокруг чего-то, что передали на вход. Прокси же может как принимать то, что нужно проксировать, так и сам управлять жизнью проксируемого объекта (например, создавать проксируемый объект).
Есть ещё один интересный паттерн :
#### "**Адаптер**" (adapter).

Он похож на декоратор — на вход декоратор принимает один объект и возвращает обёртку над этим объектом. Отличие в том, что цель у этого не изменение функционала, а адаптация одного интерфейса к другому. В Java есть очень яркий пример на этот счёт:

```java
import java.util.*;
class Main {
  public static void main(String[] arguments) {
    String[] array = {"One", "Two", "Three"};
    List<String> strings = Arrays.asList(array);
    strings.set(0, "1");
    System.out.println(Arrays.toString(array));
  }
}
```

На входе у нас массив. Далее мы создаём адаптер, приводящий массив к интерфейсу `List`. Работая с ним мы на самом деле работаем с массивом. Поэтому, добавлять элементы не выйдет, т.к. массив изначальный не изменить. И мы в этом случае получим `UnsupportedOperationException`.
Следующим интересным подходом в разработке структуры классов является паттерн: 
#### "**Компоновщик**" (Сomposite).

Интересен он тем, что некоторый набор элементов использующих один интерфейс выстраиваются в некоторую древовидную иерархию. Вызывая метод в родительском элементе мы получаем вызов этого метода по всем необходимым дочерним элементам. Яркий пример этого паттерна — UI (будь то java.awt или JSF):

```java
import java.awt.*;
class Main {
  public static void main(String[] arguments) {
    Container container = new Container();
    Component component = new java.awt.Component(){};
    System.out.println(component.getComponentOrientation().isLeftToRight());
    container.add(component);
    container.applyComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);
    System.out.println(component.getComponentOrientation().isLeftToRight());
  }
}
```

Как мы видим, мы добавили в контейнер компонент. А потом попросили контейнер применить новую ориентацию компонентов. И контейнер, зная из каких компонентов он состоит, делегировал выполнение этой команды всем дочерним компонентам.
Ещё одним из интересных паттернов является паттерн :
#### "**Мост**" (Bridge).

Называется он так, потому что описывает соединение или мост между двумя различными иерархиями классов. Одну из этих иерархий считают абстракцией, а другую — реализацией. Так выделено потому что абстракция сама не выполняет действия, а делегирует это выполнение реализации. Такой паттерн часто применяют тогда, когда есть классы "управления" и несколько видов классов "платформ" (например, Windows, Linux и т.д.). При таком подходе одна из этих иерархий (абстракция) получит ссылку на объекты другой иерархии (реализация) и будет делегировать им основную работу. Благодаря тому, что все реализации будут следовать общему интерфейсу, их можно будет взаимозаменять внутри абстракции. В Java яркие пример этому — `java.awt`:

![Паттерны проектирования в Java - 5](https://cdn.javarush.com/images/article/952083dd-9347-4cb5-91fc-50776d8d9dc8/256.webp)

Подробнее см. статью "[Patterns in Java AWT](http://www.soberit.hut.fi/tik-76.278/group6/awtpat.html)".
Среди структурных паттернов так же хочется отметить паттерн :
#### "**Фасад**" (facade).

Суть его в том, чтобы за удобным и лаконичным интерфейсом спрятать сложность использования библиотек/фрэймворков, стоящих за этим API. Например, как пример, можно привести JSF или EntityManager из JPA.
Так же есть другой паттерн, называемый :
#### "**Легковес**" (Flyweight).

Его суть заключается в том, что если у разных объектов есть одинаковое состояние, то его можно обобщить и хранить не в каждом объекте, а в одном месте. И тогда каждый объект сможет ссылаться на общу часть, что позволит сократить расходы памяти на хранение. Часто работа данного паттерна связана с предварительным кэшированием или с поддержанием пула объектов. Интересно, что этот паттерн мы тоже знаем с самого начала:

![Паттерны проектирования в Java - 6](https://cdn.javarush.com/images/article/7808e413-6d2c-4f28-86f6-c2df0ef8a00c/256.webp)

По той же аналогии сюда можно отнести пул строк. На эту тему можно прочитать статью: "[Flyweight Design Pattern](https://www.javagists.com/what-is-flyweight-design-pattern)".

![Паттерны проектирования в Java - 7](https://cdn.javarush.com/images/article/d31e3f1d-875f-49ad-8787-da19d3e89612/256.webp)
