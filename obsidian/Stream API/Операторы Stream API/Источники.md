#### `empty()`

Стрим, как и коллекция, может быть пустым, а значит всем последующем операторам нечего будет обрабатывать.  

```java
Stream.empty()
 
    .forEach(System.out::println);
// Вывода нет
```  

---
#### `of(T value)`  
`of(T... values)`

Стрим для одного или нескольких перечисленных элементов. Очень часто вижу, что используют такую конструкцию:  

```java
Arrays.asList(1, 2, 3).stream()
   
    .forEach(System.out::println);
```

однако она излишня. Вот так проще:  

```java
Stream.of(1, 2, 3)
   
    .forEach(System.out::println);
```

---
#### `ofNullable(T t)`

Появился в **Java 9**. Возвращает пустой стрим, если в качестве аргумента передан `null`, в противном случае, возвращает стрим из одного элемента.  

```java
String str = Math.random() > 0.5 ? "I'm feeling lucky" : null;
   
Stream.ofNullable(str)
   
    .forEach(System.out::println);
```
  
---
#### `generate(Supplier s)`

Возвращает стрим с бесконечной последовательностью элементов, генерируемых функцией `Supplier s`.  

```java
Stream.generate(() -> 6)
  
    .limit(6)
    .forEach(System.out::println);
// 6, 6, 6, 6, 6, 6
```

Поскольку стрим бесконечный, нужно его ограничивать или осторожно использовать, дабы не попасть в бесконечный цикл.  

---
#### `iterate(T seed, UnaryOperator f)`

Возвращает бесконечный стрим с элементами, которые образуются в результате последовательного применения функции `f` к итерируемому значению. Первым элементом будет `seed`, затем `f(seed)`, затем `f(f(seed))` и так далее.  

```java
Stream.iterate(2, x -> x + 6)
  
    .limit(6)
    .forEach(System.out::println);
// 2, 8, 14, 20, 26, 32
```

```java
Stream.iterate(1, x -> x * 2)
 
    .limit(6)
    .forEach(System.out::println);
// 1, 2, , , , 32 
```

---
#### `iterate(T seed, Predicate hasNext, UnaryOperator f)`

Появился в **Java 9**. Всё то же самое, только добавляется ещё один аргумент `hasNext`: если он возвращает `false`, то стрим завершается. Это очень похоже на цикл `for`:  

```java
for (i = seed; hasNext(i); i = f(i)) {
  
}   
```

Таким образом, с помощью `iterate` теперь можно создать конечный стрим.  

```java
Stream.iterate(2, x -> x < 25, x -> x + 6)
  
    .forEach(System.out::println);
// 2, 8, 14, 20   
```

```java
Stream.iterate(4, x -> x < 100, x -> x * 4)
   
    .forEach(System.out::println);
// , 16, 
```
  
---
#### `concat(Stream a, Stream b)`

Объединяет два стрима так, что вначале идут элементы стрима `A`, а по его окончанию последуют элементы стрима `B`.  

```java
Stream.concat(
  
        Stream.of(1, 2, 3),
        Stream.of(4, 5, 6)
)
	.forEach(System.out::println);
// 1, 2, 3, 4, 5, 6   
```
  

```java
Stream.concat(
   
        Stream.of(10),
        Stream.of(, )
)
	.forEach(System.out::println);
// 10, 4, 16   
```

---
#### `builder()`

Создаёт мутабельный объект для добавления элементов в стрим без использования какого-либо контейнера для этого. 

```java
Stream.Builder<Integer> streamBuider = Stream.<Integer>builder()
	.add(0)
	.add(1);

for (int i = 2; i <= 8; i += 2) {   
    streamBuider.accept(i);
}
   
streamBuider
    .add(9)
    .add(10)
    .build()
    .forEach(System.out::println);
// 0, 1, 2, 4, 6, 8, 9, 10
```
  
---
#### `IntStream.range(int startInclusive, int endExclusive)`
`LongStream.range(long startInclusive, long endExclusive)`

Создаёт стрим из числового промежутка (start..end), то есть от start (включительно) по end.  

```java
IntStream.range(0, 10)
   
    .forEach(System.out::println);
// 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
   

LongStream.range(-10L, -5L)
   
    .forEach(System.out::println);
// -10, -9, -8, -7, -6   
```

---
#### `IntStream.rangeClosed(int startInclusive, int endInclusive)`
`LongStream.rangeClosed(long startInclusive, long endInclusive)`

Создаёт стрим из числового промежутка (start..end), то есть от start (включительно) по end (включительно). 

```java
IntStream.rangeClosed(0, 5)
   
    .forEach(System.out::println);
// 0, 1, 2, 3, 4, 5
   

LongStream.range(-8L, -5L)
   
    .forEach(System.out::println);
// -8, -7, -6, -5
```