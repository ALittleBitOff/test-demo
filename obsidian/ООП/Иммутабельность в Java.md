Иммутабельный (неизменяемый, immutable) класс — это класс, который после инициализации не может изменить свое состояние.
То есть если в коде есть ссылка на экземпляр иммутабельного класса, то любые изменения в нем приводят к созданию нового экземпляра.

Чтобы класс был иммутабельным, он должен соответствовать следующим требованиям:

- Должен быть объявлен как final, чтобы от него нельзя было наследоваться. Иначе дочерние классы могут нарушить иммутабельность.
    
- Все поля класса должны быть приватными в соответствии с принципами инкапсуляции.
    
- Для корректного создания экземпляра в нем должны быть параметризованные конструкторы, через которые осуществляется первоначальная инициализация полей класса.
    
- Для исключения возможности изменения состояния после инстанцирования, в классе не должно быть сеттеров.
    
- Для полей-коллекций необходимо делать глубокие копии, чтобы гарантировать их неизменность.

За время работы на Java ты уже, наверное, привык к тому, что программист практически полностью управляет состоянием всех объектов.
Захотел — создал объект `Cat`. Захотел — переименовал его.
Захотел — поменял возраст, или еще что-нибудь.
Но в Java есть несколько типов данных, которые отличаются особым состоянием.
Они являются **неизменяемыми**, или **Immutable**.
Это значит, что если класс неизменяемый, состояние его объектов изменить невозможно. Примеры?
Возможно ты удивишься, но самый известный пример _Immutable_ - класса — `String`!
Казалось бы, разве мы не можем изменить значение строки?

Ну, давай попробуем:

```java
public static void main(String[] args) {

   String str1 = "I love Java";

   String str2 = str1;
   System.out.println(str2);

   str1 = "I love Python";
   System.out.println(str2);
}
```

**Вывод: _I love Java I love Java_** После того, как мы написали:

```java
str1 = "I love Python";
```

объект со строкой "I love Java" не изменился и никуда не делся.
Он благополучно существует и имеет внутри себя ровно тот же текст, что и раньше.

Код:

```java
str1 = "I love Python";
```

просто создал еще один объект, и теперь переменная `str1` указывает на него.
Но на объект "I love Java" мы никак не можем повлиять.
Так, ладно, давай попробуем по-другому!
В классе `String` полно методов, и некоторые из них, похоже с виду меняют состояние строки!
Вот, например, есть метод `replace()`. Давай поменяем слово “Java” на слово “Python” в нашей строке!

```java
public static void main(String[] args) {

   String str1 = "I love Java";

   String str2 = str1;
   System.out.println(str2);

   str1.replace("Java", "Python");
   System.out.println(str2);
}
```

**Вывод: _I love Java I love Java_** Снова не получилось!

Может, метод кривой, не работает?
Попробуем другой.
Вот, например, `substring()`. Обрезает строку по номерам переданных символов.

Давай обрежем нашу до первых 10 символов:

```java
public static void main(String[] args) {

   String str1 = "I love Java";

   String str2 = str1;
   System.out.println(str2);

   str1.substring(10);
   System.out.println(str2);
}
```

**Вывод: _I love Java I love Java_**

Ничего не поменялось.
И не должно было.
Как мы и сказали — объекты `String` неизменяемые.
А что же тогда все эти методы класса `String`?
Они же могут обрезать строку, изменить в ней символы и прочее.
Зачем они тогда нужны, если ничего не происходит?
Могут!
Но они при этом каждый раз возвращают новый объект строки.

Бесполезно писать:

```java
str1.replace("Java", "Python");
```

— ты не изменишь исходный объект.
Но если ты запишешь результат работы метода в новую переменную-ссылку, сразу увидишь разницу!

```java
public static void main(String[] args) {

   String str1 = "I love Java";

   String str2 = str1;
   System.out.println(str2);

   String str1AfterReplacement =  str1.replace("Java", "Python");
   System.out.println(str2);

   System.out.println(str1AfterReplacement);
}
```

Только так все эти методы `String` и работают.
С объектом "I love Java" ничего сделать нельзя.
Только создать новый объект, и написать:

- “Новый объект = результат каких-то манипуляций с объектом "I love Java"”.

**Какие типы еще относятся к Immutable?**
Из того, что тебе железобетонно нужно запомнить уже сейчас — все классы-обертки над примитивными типами — неизменяемые.

- `Integer`
- `Byte`
- `Character`
- `Short`
- `Boolean`
- `Long`
- `Double`
- `Float`

Все эти классы создают _Immutable_ объекты.
Сюда же относятся и классы, используемые для создания больших чисел:

- `BigInteger`
- `BigDecimal`

Объекты класса **`java.lang.StackTraceElement`** тоже неизменяемые.
Это логично: если бы кто-то мог изменять данные нашего стека, это могло бы свести на нет всю работу с ним.
Представь, что кто-нибудь заходит в **StackTrace** и меняет **OutOfMemoryError** на **FileNotFoundException**.
А тебе с этим стеком работать и искать причину ошибки.
А программа при этом вообще не использует файлы :)
Поэтому от греха подальше эти объекты сделали неизменяемыми.
Ну, со **StackTraceElement** более-менее понятно.
А зачем кому-то понадобилось делать неизменяемыми строки?
В чем проблема, если бы можно было менять их значения.
Наверное, даже удобнее бы было :/
Причин тут несколько.
Во-первых, экономия памяти.
Неизменяемые строки можно помещать в `String Pool` и использовать каждый раз одну и ту же вместо создания новых.
Во-вторых, безопасность.
Например, большинство логинов и паролей в любой программе — строки.
Возможность их изменения могла бы повлечь проблемы с авторизацией.