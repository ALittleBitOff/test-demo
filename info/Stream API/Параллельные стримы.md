Стримы бывают последовательными (**sequential**) и параллельными (**parallel**). Последовательные выполняются только в текущем потоке, а вот параллельные используют общий пул [ForkJoinPool.commonPool()](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html#commonPool--). При этом элементы разбиваются (если это возможно) на несколько групп и обрабатываются в каждом потоке отдельно. Затем на нужном этапе группы объединяются в одну для предоставления конечного результата.  
  
Чтобы получить параллельный стрим, нужно либо вызвать метод `parallelStream()` вместо `stream()`, либо превратить обычный стрим в параллельный, вызвав промежуточный оператор `parallel`.  

```java
list.parallelStream()
   
    .filter(x -> x > 10)
    .map(x -> x * 2)
    .collect(Collectors.toList());

IntStream.range(0, 10)
   
    .parallel()
    .map(x -> x * 10)
    .sum();
```

  
Работа с потоконебезопасными коллекциями, разбиение элементов на части, создание потоков, объединение частей воедино, всё это кроется в реализации **Stream API**. От нас лишь требуется вызвать нужный метод и проследить, чтобы функции в операторах не зависели от каких-либо внешних факторов, иначе есть риск получить неверный результат или ошибку.  
  
Вот так делать нельзя:  

```java
final List<Integer> ints = new ArrayList<>();
   
IntStream.range(0, 1000000)
   
    .parallel()
    .forEach(i -> ints.add(i));
System.out.println(ints.size());
```

Это код Шредингера. Он может нормально выполниться и показать 1000000, может выполниться и показать 869877, а может и упасть с ошибкой
`Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 332 at java.util.ArrayList.add(ArrayList.java:459)`.  
  
Поэтому разработчики настоятельно просят воздержаться от побочных эффектов в лямбдах, то тут, то там говоря в документации о невмешательстве (**non-interference**).