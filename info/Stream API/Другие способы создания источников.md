Стрим из сплитератора — это самый эффективный способ создания стрима, но кроме него есть и другие способы.  
### `Стрим из итератора`

Благодаря классу `Spliterators`, можно преобразовать любой итератор в сплитератор. Вот пример создания стрима из итератора, генерирующего бесконечную последовательность чисел Фибоначчи.  


```java
public class FibonacciIterator implements Iterator<BigInteger> {
 
	private BigInteger a = BigInteger.ZERO;
    private BigInteger b = BigInteger.ONE;
    @Override
    public boolean hasNext() {
        return true;
    }
    @Override
    public BigInteger next() {
         BigInteger result = a;
         a = b;
         b = result.add(b);
         return result;
     }
 }
 
 StreamSupport.stream(
 
     Spliterators.spliteratorUnknownSize(
         new FibonacciIterator(),
         Spliterator.ORDERED | Spliterator.SORTED),
     false /* is parallel*/)
     .limit(10)
     .forEach(System.out::println);
```
### `Stream.iterate + map`

Можно воспользоваться двумя операторами: `iterate + map`, чтобы создать всё тот же стрим из чисел Фибоначчи.  

```java
Stream.iterate(
 
    new BigInteger[] { BigInteger.ZERO, BigInteger.ONE },
    t -> new BigInteger[] { t[1], t[0].add(t[1]) })
    .map(t -> t[0])
    .limit(10)
    .forEach(System.out::println);
```
  
Для удобства можно обернуть всё в метод и вызывать `fibonacciStream().limit(10).forEach(...)`.  
### `IntStream.range + map`

Ещё один гибкий и удобный способ создать стрим. Если у вас есть какие-то данные, которые можно получить по индексу, то можно создать числовой промежуток при помощи оператора range, затем поэлементно с помощью него обращаться к данным через **map/mapToObj**.  

```java
IntStream.range(0, 200)
 
    .mapToObj(i -> fibonacci(i))
    .forEach(System.out::println);
JSONArray arr = ...
 
IntStream.range(0, arr.length())
 
    .mapToObj(JSONArray::getJSONObject)
    .map(obj -> ...)
    .forEach(System.out::println);
```
## Примеры

Прежде чем перейти к более приближенным к жизни примерам, стоит сказать, что если код уже написан без стримов и работает хорошо, не нужно сломя голову всё переписывать. Также бывает ситуации, когда красиво реализовать задачу с использованием Stream API не получается, в таком случае смиритесь и не тяните стримы за уши.  
  
Дан массив аргументов. Нужно получить Map, где каждому ключу будет соответствовать своё значение.  


```java
String[] arguments = {"-i", "in.txt", "--limit", "40", "-d", "1", "-o", "out.txt"};
 
Map<String, String> argsMap = new LinkedHashMap<>(arguments.length / 2);
 
for (int i = 0; i < arguments.length; i += 2) {
 
    argsMap.put(arguments[i], arguments[i + 1]);
}
 
argsMap.forEach((key, value) -> System.out.format("%s: %s%n", key, value));
 
// -i: in.txt
 
// --limit: 40
 
// -d: 1
 
// -o: out.txt
```    

Быстро и понятно. А вот для обратной задачи — сконвертировать Map с аргументами в массив строк, стримы помогут.  


```java
String[] args = argsMap.entrySet().stream()
 
        .flatMap(e -> Stream.of(e.getKey(), e.getValue()))
        .toArray(String[]::new);
System.out.println(String.join(" ", args));
 
// -i in.txt --limit 40 -d 1 -o out.txt
```    
  
Дан список студентов.  


```java
List<Student> students = Arrays.asList(
 
        new Student("Alex", Speciality.Physics, 1),
        new Student("Rika", Speciality.Biology, 4),
        new Student("Julia", Speciality.Biology, 2),
        new Student("Steve", Speciality.History, 4),
        new Student("Mike", Speciality.Finance, 1),
        new Student("Hinata", Speciality.Biology, 2),
        new Student("Richard", Speciality.History, 1),
        new Student("Kate", Speciality.Psychology, 2),
        new Student("Sergey", Speciality.ComputerScience, 4),
        new Student("Maximilian", Speciality.ComputerScience, 3),
        new Student("Tim", Speciality.ComputerScience, 5),
        new Student("Ann", Speciality.Psychology, 1)
        );
enum Speciality {
 
    Biology, ComputerScience, Economics, Finance,
    History, Philosophy, Physics, Psychology
}
```    

У класса Student реализованы все геттеры и сеттеры, `toString` и `equals+hashCode`.  
  
Нужно сгруппировать всех студентов по курсу.  


```java
students.stream()
 
        .collect(Collectors.groupingBy(Student::getYear))
        .entrySet().forEach(System.out::println);
// 1=[Alex: Physics 1, Mike: Finance 1, Richard: History 1, Ann: Psychology 1]
 
// 2=[Julia: Biology 2, Hinata: Biology 2, Kate: Psychology 2]
 
// 3=[Maximilian: ComputerScience 3]
 
// 4=[Rika: Biology 4, Steve: History 4, Sergey: ComputerScience 4]
 
// 5=[Tim: ComputerScience 5]
```
  
Вывести в алфавитном порядке список специальностей, на которых учатся перечисленные в списке студенты.  

```java
students.stream()
 
        .map(Student::getSpeciality)
        .distinct()
        .sorted(Comparator.comparing(Enum::name))
        .forEach(System.out::println);
// Biology
 
// ComputerScience
 
// Finance
 
// History
 
// Physics
 
// Psychology
```    
  
Вывести количество учащихся на каждой из специальностей.  

```java
students.stream()
 
        .collect(Collectors.groupingBy(
                Student::getSpeciality, Collectors.counting()))
        .forEach((s, count) -> System.out.println(s + ": " + count));
// Psychology: 2
 
// Physics: 1
 
// ComputerScience: 3
 
// Finance: 1
 
// Biology: 3
 
// History: 2
```    
  
Сгруппировать студентов по специальностям, сохраняя алфавитный порядок специальности, а затем сгруппировать по курсу.  


```java
Map<Speciality, Map<Integer, List<Student>>> result = students.stream()
 
        .sorted(Comparator
                .comparing(Student::getSpeciality, Comparator.comparing(Enum::name))
                .thenComparing(Student::getYear)
        )
        .collect(Collectors.groupingBy(
                Student::getSpeciality,
                LinkedHashMap::new,
                Collectors.groupingBy(Student::getYear)));
```
  
Теперь это всё красиво вывести.  


```java
result.forEach((s, map) -> {
 
    System.out.println("-= " + s + " =-");
    map.forEach((year, list) -> System.out.format("%d: %s%n", year, list.stream()
            .map(Student::getName)
            .sorted()
            .collect(Collectors.joining(", ")))
    );
    System.out.println();
});  
```

| Biology          | ComputerScience | Finance | History    | Physics | Psychology |
| ---------------- | --------------- | ------- | ---------- | ------- | ---------- |
| 2: Hinata, Julia | 3: Maximilian   | 1: Mike | 1: Richard | 1: Alex | 1: Ann     |
| 4: Rika          | 4: Sergey       |         | 4: Steve   |         | 2: Kate    |
|                  | 5: Tim          |         |            |         |            |

Проверить, есть ли третьекурсники среди учащихся всех специальностей кроме физики и CS.  

```java
students.stream()
 
        .filter(s -> !EnumSet.of(Speciality.ComputerScience, Speciality.Physics)
                .contains(s.getSpeciality()))
        .anyMatch(s -> s.getYear() == 3);
// false
```
  
Вычислить число Пи методом Монте-Карло.  


```java
final Random rnd = new Random();
 
final double r = 1000.0;
 
final int max = 10000000;
 
long count = IntStream.range(0, max)
 
        .mapToObj(i -> rnd.doubles(2).map(x -> x * r).toArray())
        .parallel()
        .filter(arr -> Math.hypot(arr[0], arr[1]) <= r)
        .count();
System.out.println(4.0 * count / max);
 
// 3.1415344
```

Вывести таблицу умножения.  

```java
IntStream.rangeClosed(2, 9)
 
        .boxed()
        .flatMap(i -> IntStream.rangeClosed(2, 9)
                .mapToObj(j -> String.format("%d * %d = %d", i, j, i * j))
        )
        .forEach(System.out::println);
// 2 * 2 = 4
 
// 2 * 3 = 6
 
// 2 * 4 = 8
 
// 2 * 5 = 10

// ...

// 9 * 7 = 63

// 9 * 8 = 72

// 9 * 9 = 81
```

Или более экзотический вариант, в 4 столбца, как на школьных тетрадях.  

```java
IntFunction<IntFunction<String>> function = i -> j -> String.format("%d x %2d = %2d", i, j, i * j);
 
IntFunction<IntFunction<IntFunction<String>>> repeaterX = count -> i -> j ->
 
        IntStream.range(0, count)
                .mapToObj(delta -> function.apply(i + delta).apply(j))
                .collect(Collectors.joining("\t"));
IntFunction<IntFunction<IntFunction<IntFunction<String>>>> repeaterY = countY -> countX -> i -> j ->
 
        IntStream.range(0, countY)
                .mapToObj(deltaY -> repeaterX.apply(countX).apply(i).apply(j + deltaY))
                .collect(Collectors.joining("\n"));
 IntFunction<String> row = i -> repeaterY.apply(10).apply(4).apply(i).apply(1) + "\n";
 
IntStream.of(2, 6).mapToObj(row).forEach(System.out::println);
```

![multable.jpg](https://annimon.com/ablogs/file808/multable.jpg "multable.jpg")  
Но это, конечно же, шутка. Писать такой код вас никто не заставляет.