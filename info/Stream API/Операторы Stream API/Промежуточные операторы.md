#### `filter(Predicate predicate)`

Фильтрует стрим, принимая только те элементы, которые удовлетворяют заданному условию. 

```java
Stream.of(1, 2, 3)
   
    .filter(x -> x == 10)
    .forEach(System.out::print);
// Вывода нет, так как после фильтрации стрим станет пустым
   
Stream.of(120, 410, 85, 32, 314, 12)
   
    .filter(x -> x > 100)
    .forEach(System.out::println);
// 120, 410, 314
```  

```java
IntStream.range(2, 9)
   
    .filter(x -> x %  == 0)
    .forEach(System.out::println);
// 3, 6   
```
  
---
#### `map(Function mapper)`

Применяет функцию к каждому элементу и затем возвращает стрим, в котором элементами будут результаты функции. map можно применять для изменения типа элементов.  
  
- `Stream.mapToDouble(ToDoubleFunction mapper)`
- `Stream.mapToInt(ToIntFunction mapper)`
- `Stream.mapToLong(ToLongFunction mapper)`

- `IntStream.mapToObj(IntFunction mapper)`
- `IntStream.mapToLong(IntToLongFunction mapper)`
- `IntStream.mapToDouble(IntToDoubleFunction mapper)`
  
Специальные операторы для преобразования объектного стрима в примитивный, примитивного в объектный, либо примитивного стрима одного типа в примитивный стрим другого. 

```java
Stream.of("3", "4", "5")
   
    .map(Integer::parseInt)
    .map(x -> x + 10)
    .forEach(System.out::println);
// 13, 14, 15   

Stream.of(120, 410, 85, 32, 314, 12)
   
    .map(x -> x + 11)
    .forEach(System.out::println);
// 131, 421, 96, 43, 325, 23   
```
  

```java
Stream.of("10", "11", "")
   
    .map(x -> Integer.parseInt(x, 16))
    .forEach(System.out::println);
// , , 50
```    

---
#### `flatMap(Function<T, Stream<R>> mapper)`

Один из самых интересных операторов. Работает как `map`, но с одним отличием — можно преобразовать один элемент в ноль, один или множество других.  
  
- `flatMapToDouble(Function mapper)`
- `flatMapToInt(Function mapper)`
- `flatMapToLong(Function mapper)`
  
Как и в случае с `map`, служат для преобразования в примитивный стрим.  
  
Для того, чтобы один элемент преобразовать в ноль элементов, нужно вернуть `null`, либо пустой стрим. Чтобы преобразовать в один элемент, нужно вернуть стрим из одного элемента, например, через `Stream.of(x)`. Для возвращения нескольких элементов, можно любыми способами создать стрим с этими элементами.  
  
```java
Stream.of(2, 3, 0, 1, 3)
	.flatMap(x -> IntStream.range(0, x))
	.forEach(System.out::println);
// 0, 1, 0, 1, 2, 0, 0, 1, 2
```  
 

```java
Stream.of(1, 2, 3, 4, 5, 6)
   
    .flatMap(x -> {
         switch (x % 2) {
             case 0:
                 return Stream.of(x, x*x, x*x*2);
             case 1:
                 return Stream.of(x);
             case 2:
             default:
                 return Stream.empty();
         }
     })
    .forEach(System.out::println);
// 1, 3, 9, 18, 4, 6, 36, 72
```    

---
#### `mapMulti(BiConsumer<T, Consumer<R>> mapper)`

Появился в **Java 16**. Этот оператор похож на `flatMap`, но использует императивный подход при работе. Теперь вместе с элементом стрима приходит ещё и Consumer, в который можно передать одно или несколько значений, либо не передавать вовсе.  
  
Вот как было с `flatMap`:  


```java
Stream.of(1, 2, 3, 4, 5, 6)
   
	.flatMap(x -> {
		if (x % 2 == 0) {
			return Stream.of(-x, x);
		}
		return Stream.empty();
	})
	.forEach(System.out::println);
// -2, 2, -4, 4, -6, 6   
```

А вот так можно переписать с использованием `mapMulti`:  

```java
Stream.of(1, 2, 3, 4, 5, 6)

	.mapMulti((x, consumer) -> {
		 if (x % 2 == 0) {
			 consumer.accept(-x);
			 consumer.accept(x);
		 }
    })
	.forEach(System.out::println);
// -2, 2, -4, 4, -6, 6   
```
  
- `mapMultiToDouble(BiConsumer<T, DoubleConsumer> mapper)`
- `mapMultiToInt(BiConsumer<T, IntConsumer> mapper)`
- `mapMultiToLong(BiConsumer<T, LongConsumer> mapper)`
  
Служат для преобразования в примитивный стрим.  
  
У `mapMulti` есть несколько преимуществ перед `flatMap`. Во-первых, если приходится пропускать значения (как в примере выше, где пропускались нечётные элементы), то не будет затрат на создание пустого стрима. Во-вторых, `consumer` легко передать в другой метод, в котором можно проводить преобразования, включая рекурсивные.  

```java
void processSerializable(Serializable ser, Consumer<String> consumer) {
 
    if (ser instanceof String str) {
        consumer.accept(str);
    } else if (ser instanceof List) {
        for (Serializable s : (List<Serializable>) ser) {
            processSerializable(s, consumer);
        }
    }
}
   
Serializable arr(Serializable... elements) {

    return Arrays.asList(elements);
}
  
Stream.of(arr("A", "B"), "C", "D", arr(arr("E"), "F"), "G")
  
    .mapMulti(this::processSerializable)
    .forEach(System.out::println);
// A, B, C, D, E, F, G
```    

---
#### `gather(Gatherer<T, R> gatherer)`

Появился в **Java 22**. `gather` позволяет создавать свои промежуточные операторы. Для этого нужно создать объект [Gatherer](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherer.html), в котором прописать логику обработки. Например:  

```java
public <T> Gatherer<T, Void, T> twice() {
  
    return Gatherer.of((state, element, downstream) -> {
        downstream.push(element);
        downstream.push(element);
        return true;
    });
}
   
Stream.of("A", "B", "C", "D").gather(twice()).toList()
   
// A, A, B, B, C, C, D, D
```    
  
В классе [Gatherers](https://docs.oracle.com/en/java/javase/23/docs/api/java.base/java/util/stream/Gatherers.html) уже есть несколько полезных заготовленных операторов:  

```java
IntStream.rangeClosed(1, 10)
   
        .boxed()
        .gather(Gatherers.windowFixed(3))
        .forEach(System.out::println);
// [1, 2, 3]
// [4, 5, 6]
// [7, 8, 9]
// [10]
   
IntStream.rangeClosed(1, 10)
   
        .boxed()
        .gather(Gatherers.windowSliding(5))
        .forEach(System.out::println);
// [1, 2, 3, 4, 5]
// [2, 3, 4, 5, 6]
// [3, 4, 5, 6, 7]
// [4, 5, 6, 7, 8]
// [5, 6, 7, 8, 9]
// [6, 7, 8, 9, 10]   
```
  
---
#### `limit(long maxSize)`

Ограничивает стрим maxSize элементами.  

```java
Stream.of(120, 410, 85, 32, 314, 12)
    
	.limit(4)
	.forEach(System.out::println);
// 120, 410, 85, 32    
```

```java
Stream.of(120, 410, 85, 32, 314, 12)

    .limit()
    .limit(5)
    .forEach(System.out::println);
// 120, 410  

Stream.of(19)
   
    .limit()
    .forEach(System.out::println);
// Вывода нет   
```
  
---
#### `skip(long n)`

Пропускает `n` элементов стрима.  

```java
Stream.of(5, 10)
   
    .skip(40)
    .forEach(System.out::println);
// Вывода нет
   
Stream.of(120, 410, 85, 32, 314, 12)
   
    .skip(2)
    .forEach(System.out::println);
// 85, 32, 314, 12    
```

```java
IntStream.range(0, 10)
   
    .limit(5)
    .skip(3)
    .forEach(System.out::println);
// , 
IntStream.range(0, 10)
  
    .skip(5)
    .limit(3)
    .skip(1)
    .forEach(System.out::println);
// , 
```  

---
#### `sorted()`  
`sorted(Comparator comparator)`

Сортирует элементы стрима. Причём работает этот оператор очень хитро: если стрим уже помечен как отсортированный, то сортировка проводиться не будет, иначе соберёт все элементы, отсортирует их и вернёт новый стрим, помеченный как отсортированный.  


```java
IntStream.range(0, 100000000)
   
    .sorted()
    .limit(3)
    .forEach(System.out::println);
// 0, 1, 2
   
IntStream.concat(
   
        IntStream.range(0, 100000000),
        IntStream.of(-1, -2))
    .sorted()
    .limit(3)
    .forEach(System.out::println);
// Exception in thread "main" java.lang.OutOfMemoryError: Java heap space   

Stream.of(120, 410, 85, 32, 314, 12)
  
	.sorted()
	.forEach(System.out::println);
// 12, 32, 85, 120, 314, 410
```    

```java
Stream.of(120, 410, 85, 32, 314, 12)
   
    .sorted(Comparator.Order())
    .forEach(System.out::println);
// 410, 314, 120, 85, 32, 12
```    

---
#### `distinct()`

Убирает повторяющиеся элементы и возвращаем стрим с уникальными элементами. Как и в случае с `sorted`, смотрит, состоит ли уже стрим из уникальных элементов и если это не так, отбирает уникальные и помечает стрим как содержащий уникальные элементы.  

```java
Stream.of(2, 1, 8, 1, 3, 2)
   
    .distinct()
    .forEach(System.out::println);
// 2, 1, 8, 3
```    


```java
IntStream.concat(
 
        IntStream.range(2, 5),
        IntStream.range(0, 4))
    .distinct()
    .forEach(System.out::println);
// , , , , 
```

---
#### `peek(Consumer action)`

Выполняет действие над каждым элементом стрима и при этом возвращает стрим с элементами исходного стрима. Служит в основном для отладки, либо для того, чтобы передать элемент куда-нибудь, не разрывая при этом цепочку операторов (вы же помните, что `forEach` — терминальный оператор и после него стрим завершается?).  

```java
Stream.of(0, 3, 0, 0, 5)
   
    .peek(x -> System.out.format("before distinct: %d%n", x))
    .distinct()
    .peek(x -> System.out.format("after distinct: %d%n", x))
    .map(x -> x * x)
    .forEach(x -> System.out.format("after map: %d%n", x));
// before distinct: 0
// after distinct: 0 
// after map: 0
// before distinct: 3
// after distinct: 3
// after map: 9
// before distinct: 1
// after distinct: 1
// after map: 1
// before distinct: 5
// before distinct: 0
// before distinct: 5
// after distinct: 5
// after map: 25 
```
  
Внимание! Если этот оператор не вносит никаких изменений в стрим, он может быть автоматически исключён из цепочки ради оптимизации.  


```java
long count = IntStream.range(0, 10)
 
    .peek(System.out::println)
    .count();
System.out.println(count);
```
В этом примере `peek` никак не влияет на количество элементов, поэтому при выполнении он пропустится и выведется только результат 10.  

---
#### `takeWhile(Predicate predicate)`

Появился в **Java 9**. Возвращает элементы до тех пор, пока они удовлетворяют условию, то есть функция-предикат возвращает true. Это как `limit`, только не с числом, а с условием.  

```java
Stream.of(1, 2, 3, 4, 2, 5)
 
    .takeWhile(x -> x < 3)
    .forEach(System.out::println);
// 1, 2
```

```java
IntStream.range(2, 7)
 
    .takeWhile(x -> x != )
    .forEach(System.out::println);
// 2, 3, 4
```
  
---
#### `dropWhile(Predicate predicate)`

Появился в **Java 9**. Пропускает элементы до тех пор, пока они удовлетворяют условию, затем возвращает оставшуюся часть стрима. Если предикат вернул для первого элемента `false`, то ни единого элемента не будет пропущено. Оператор подобен `skip`, только работает по условию.  


```java
Stream.of(1, 2, 3, 4, 2, 5)
 
    .dropWhile(x -> x >= 3)
    .forEach(System.out::println);
// 1, 2, 3, 4, 2, 5
 
Stream.of(1, 2, 3, 4, 2, 5)
 
    .dropWhile(x -> x < 3)
    .forEach(System.out::println);
// 3, 4, 2, 5
```

```java
IntStream.range(2, 7)
 
    .dropWhile(x -> x < 7)
    .forEach(System.out::println);
// 5, 6
 
IntStream.of(1, 3, 2, 0, 5, 4)
 
    .dropWhile(x -> x  2 == 1)
    .forEach(System.out::println);
// 2, 0, 5, 6
```
  
---
#### `boxed()`

Преобразует примитивный стрим в объектный.  


```java
DoubleStream.of(0.1, Math.PI)
 
    .boxed()
    .map(Object::getClass)
    .forEach(System.out::println);
// class java.lang.Double
// class java.lang.Double
```