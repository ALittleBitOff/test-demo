#### `void forEach(Consumer action)`

Выполняет указанное действие для каждого элемента стрима.  

```java
Stream.of(120, 410, 85, 32, 314, 12)
 
    .forEach(x -> System.out.format("%s, ", x));
// 120, 410, 85, 32, 314, 12
```

#### `void forEachOrdered(Consumer action)`

Тоже выполняет указанное действие для каждого элемента стрима, но перед этим добивается правильного порядка вхождения элементов. Используется для параллельных стримов, когда нужно получить правильную последовательность элементов.  

```java
IntStream.range(0, 100000)
 
    .parallel()
    .filter(x -> x % 10000 == 0)
    .map(x -> x / 10000)
    .forEach(System.out::println);
// 5, 6, 7, 3, 4, 8, 0, 9, 1, 2
 
IntStream.range(0, 100000)
 
    .parallel()
     .filter(x -> x % 10000 == 0)
     .map(x -> x / 10000)
     .forEachOrdered(System.out::println);
 // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
```    

---
#### `long count()`

Возвращает количество элементов стрима.  


```java
long count = IntStream.range(0, 10)
 
    .flatMap(x -> IntStream.range(0, x))
    .count();
System.out.println(count);
 
// 45
 
System.out.println(
 
    IntStream.rangeClosed(-3, )
        .count()
);
 
// 10
 
System.out.println(

	Stream.of(0, 2, 9, 13, 5, 11)
	 .(x -> x  2)
	 .filter(x -> x % 2 == 1)
	 .count()
);

// 0
```    

---
#### `R collect(Collector collector)
`
Один из самых мощных операторов **Stream API**. С его помощью можно собрать все элементы в список, множество или другую коллекцию, сгруппировать элементы по какому-нибудь критерию, объединить всё в строку и т.д.. В классе `java.util.stream.Collectors` очень много методов на все случаи жизни, мы рассмотрим их позже. При желании можно [написать свой коллектор](https://annimon.com/article/2778#collector-implementation), реализовав интерфейс Collector.  


```java
List<Integer> list = Stream.of(1, 2, 3)
 
    .collect(Collectors.toList());
// list: [1, 2, 3]
 
String s = Stream.of(1, 2, 3)
 
    .map(String::valueOf)
    .collect(Collectors.joining("-", "<", ">"));
// s: "<1-2-3>"
```    

#### `R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)`

То же, что и `collect(collector)`, только параметры разбиты для удобства. Если нужно быстро сделать какую-то операцию, нет нужды реализовывать интерфейс `Collector`, достаточно передать три лямбда-выражения.  
  
supplier должен поставлять новые объекты (контейнеры), например new ArrayList(), accumulator добавляет элемент в контейнер, combiner необходим для параллельных стримов и объединяет части стрима воедино.  

```java
List<String> list = Stream.of("a", "b", "c", "d")
 
    .collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
// list: ["a", "b", "c", "d"] 
``` 

---
#### `Object[] toArray()`

Возвращает нетипизированный массив с элементами стрима.  
  
`A[] toArray(IntFunction<A[]> generator)`
Аналогично, только возвращает типизированный массив.  
  
```java
String[] elements = Stream.of("a", "b", "c", "d")
 
    .toArray(String[]::new);
// elements: ["a", "b", "c", "d"]
```    

---
#### `List<T> toList()`

Наконец-то добавлен в **Java 16**. Возвращает список, подобно `collect(Collectors.toList())`. Отличие в том, что теперь возвращаемый список гарантированно нельзя будет модифицировать. Любое добавление или удаление элементов в полученный список будет сопровождаться исключением `UnsupportedOperationException`.  
  

```java
List<String> elements = Stream.of("a", "b", "c", "d")
	.map(String::toUpperCase)
	.toList();
// elements: ["A", "B", "C", "D"]
```  

---
#### `T reduce(T identity, BinaryOperator accumulator)`
`U reduce(U identity, BiFunction accumulator, BinaryOperator combiner)`

Ещё один полезный оператор. Позволяет преобразовать все элементы стрима в один объект. Например, посчитать сумму всех элементов, либо найти минимальный элемент.  
  
Сперва берётся объект `identity` и первый элемент стрима, применяется функция `accumulator` и `identity` становится её результатом. Затем всё продолжается для остальных элементов.

```java
int sum = Stream.of(1, 2, 3, 4, 5)
 
	.reduce(10, (acc, x) -> acc + x);
// sum: 25
```

#### `Optional reduce(BinaryOperator accumulator)`

Этот метод отличается тем, что у него нет начального объекта `identity`. В качестве него служит первый элемент стрима. Поскольку стрим может быть пустой и тогда `identity` объект не присвоится, то результатом функции служит `Optional`, позволяющий обработать и эту ситуацию, вернув `Optional.empty()`.  

```java
Optional<Integer> result = Stream.<Integer>empty()
 
    .reduce((acc, x) -> acc + x);
System.out.println(result.isPresent());
 
// false
 
Optional<Integer> sum = Stream.of(1, 2, 3, 4, 5)
 
    .reduce((acc, x) -> acc + x);
System.out.println(sum.get());
 
// 15
```    


```java
int sum = IntStream.of(2, 4, 6, 8)
 
    .reduce(, (acc, x) -> acc + x);
// sum: 25
 
int product = IntStream.range(0, 10)
 
    .filter(x -> x++ % 4 == 0)
    .reduce((acc, x) -> acc * x)
    .getAsInt();
// product: 
```
  
---
#### `Optional min(Comparator comparator)`

#### `Optional max(Comparator comparator)`

Поиск минимального/максимального элемента, основываясь на переданном компараторе. Внутри вызывается `reduce`:  

```java
reduce((a, b) -> comparator.compare(a, b) <= 0 ? a : b));
 
reduce((a, b) -> comparator.compare(a, b) >= 0 ? a : b));
```

```java
int min = Stream.of(20, 11, 45, 78, 13)
 
    .min(Integer::compare).get();
// min: 11
 
int max = Stream.of(20, 11, 45, 78, 13)
 
    .max(Integer::compare).get();
// max: 78
```
  
---
#### `Optional findAny()`

Возвращает первый попавшийся элемент стрима. В параллельных стримах это может быть действительно любой элемент, который лежал в разбитой части последовательности.  
#### `Optional findFirst()`

Гарантированно возвращает первый элемент стрима, даже если стрим параллельный.  
  
Если нужен любой элемент, то для параллельных стримов быстрее будет работать `findAny()`


```java
int anySeq = IntStream.range(4, 65536)
 
    .findAny()
    .getAsInt();
// anySeq: 4
 
int firstSeq = IntStream.range(4, 65536)
 
    .findFirst()
    .getAsInt();
// firstSeq: 4
 
 int anyParallel = IntStream.range(4, 65536)
 
     .parallel()
     .findAny()
     .getAsInt();
// anyParallel: 32770
 
 int firstParallel = IntStream.range(4, 65536)
 
     .parallel()
     .findFirst()
     .getAsInt();
// firstParallel: 4
```    

---
#### `boolean allMatch(Predicate predicate)`

Возвращает `true`, если все элементы стрима удовлетворяют условию `predicate`. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет `false`, то оператор перестаёт просматривать элементы и возвращает `false`.  

```java
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .allMatch(x -> x <= 7);
// result: true
 
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .allMatch(x -> x < 3);
// result: false
```

```java
boolean result = Stream.of(120, 410, 85, 32, 314, 12)
 
    .allMatch(x -> x % 2 == 0);
// result: 
```

---
#### `boolean anyMatch(Predicate predicate)`

Возвращает `true`, если хотя бы один элемент стрима удовлетворяет условию `predicate`. Если такой элемент встретился, нет смысла продолжать перебор элементов, поэтому сразу возвращается результат.  

```java
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .anyMatch(x -> x == 3);
// result: true
 
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .anyMatch(x -> x == 8);
// result: false
```


```java
boolean result = Stream.of(120, 410, 85, 32, 314, 12)
 
    .anyMatch(x -> x % 22 == 0);
// result: 
```
  
---
#### `boolean noneMatch(Predicate predicate)`

Возвращает `true`, если, пройдя все элементы стрима, ни один не удовлетворил условию `predicate`. Если встречается какой-либо элемент, для которого результат вызова функции-предиката будет `true`, то оператор перестаёт перебирать элементы и возвращает `false`.  

```java
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .noneMatch(x -> x == 9);
// result: true
 
boolean result = Stream.of(1, 2, 3, 4, 5)
 
    .noneMatch(x -> x == 3);
// result: false
```

```java
boolean result = Stream.of(120, 410, 86, 32, 314, 12)
 
    .noneMatch(x -> x % 2 == 1);
// result: 
```
  
---
#### `OptionalDouble average()`

Только для примитивных стримов. Возвращает среднее арифметическое всех элементов. Либо `Optional.empty`, если стрим пуст.  

```java
double result = IntStream.range(2, 16)
 
    .average()
    .getAsDouble();
// result: 8.5
```

---
#### `sum()`

Возвращает сумму элементов примитивного стрима. Для `IntStream` результат будет типа `int`, для `LongStream` — `long`, для `DoubleStream` — `double`.  

```java
long result = LongStream.range(2, 16)
 
    .sum();
// result: 119 
```

---
#### `IntSummaryStatistics summaryStatistics()`

Полезный метод примитивных стримов. Позволяет собрать статистику о числовой последовательности стрима, а именно:
- количество элементов
- их сумму
- среднее арифметическое
- минимальный элемент
- максимальный элемент  


```java
LongSummaryStatistics stats = LongStream.range(2, 16)
 
    .summaryStatistics();
System.out.format("count: %d%n", stats.getCount());
 
System.out.format("sum: %d%n", stats.getSum());
 
System.out.format("average: %.1f%n", stats.getAverage());
 
System.out.format("min: %d%n", stats.getMin());
 
System.out.format("max: %d%n", stats.getMax());
 
//   count: 14
 
//     sum: 119
 
// average: 8,5
 
//     min: 2
 
//     max: 15
```