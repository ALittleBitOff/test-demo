У стримов есть некоторые особенности. Во-первых, обработка не начнётся до тех пор, пока не будет вызван терминальный оператор. `list.stream().filter(x -> x > 100);` не возьмёт ни единого элемента из списка. Во-вторых, стрим после обработки нельзя переиспользовать.  

```java
Stream<String> stream = list.stream();
   
stream.forEach(System.out::println);
   
stream.filter(s -> s.contains("Stream API"));
   
stream.forEach(System.out::println);
```

Код на второй строке выполнится, а вот на третьей выбросит исключение `java.lang.IllegalStateException: stream has already been operated upon or closed.`
  
Исходя из первой особенности, делаем вывод, что обработка происходит от терминального оператора к источнику. Это действительно так и это удобно. Мы можем в качестве источника использовать генерируемую бесконечную последовательность, скажем, факториала или чисел Фибоначчи, но обрабатывать лишь некоторую её часть.  
  
  
Пока мы не присоединили терминальный оператор, доступа к источнику не проводилось. Как только появился терминальный оператор `forEach`, он стал запрашивать элементы у стоящего перед ним оператора `limit`. Тот в свою очередь обращается к map, map к `filter`, а `filter` уже обращается к источнику. Затем элементы поступают в прямом порядке: источник, `filter`, `map`, `limit` и `forEach`.  
Пока какой-либо из операторов не обработает элемент должным образом, новые запрошены не будут.  
Как только через оператор `limit` прошло 3 элемента, он переходит в закрытое состояние и больше не будет запрашивать элементы у `map`. `forEach` запрашивает очередной элемент, но `limit` сообщает, что больше не может поставить элементов, поэтому `forEach` делает вывод, что элементы закончились и прекращает работу.  
  
Такой подход зовётся **pull iteration**, то есть элементы запрашиваются у источника по мере надобности. К слову, в **RxJava** реализован **push iteration** подход, то есть источник сам уведомляет, что появились элементы и их нужно обработать.